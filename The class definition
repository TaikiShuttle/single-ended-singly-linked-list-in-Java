package single_ended_singlely_linked_list;

public class single_ended_singlely_linked_list
{
    static private class node
    {
        //elements contained in a node class
        private node next;
        private int number;

        //The constructor of this node class
        //The default constructor
        public node()
        {
            this.number = 0;
            this.next = null;
        }

        //Constructor with one argument
        public node(int i)
        {
            this.number = i;
            this.next = null;
        }
    }

    //The only private element should be the first node
    private node first;

    //Use space to change for time
    private int num_of_elements;

    //Return true if the list is empty
    public boolean isEmpty()
    {
        return (first==null);
    }

    //remove the ith node of the list, if there is no such node, throw an exception
    //Note that the script of the first element is 1, not 0
    public int remove_by_script(int i) throws Exception
    {
        if(i>num_of_elements || i<=0)
        {
            throw new Exception("index_out_of_range");
        }
        else
        {
            if(i==1)
            {
                node victim = first;
                first = victim.next;
                num_of_elements--;
                return victim.number;
            }
            else if(i==2)
            {
                node victim = first.next;
                first.next = victim.next;
                num_of_elements--;
                return victim.number;
            }
            else
            {
                node current_node = first;
                for(int j=0; j<i-2;j++)
                {
                    current_node = current_node.next;
                }
                node victim = current_node.next;
                current_node.next = victim.next;
                num_of_elements--;
                return victim.number;
            }
        }
    }

    //remove the specified node by its value
    //throw an exception if it does not exist
    public int remove_by_value(int val) throws Exception
    {
        if(first!=null)
        {
            //if the first node is the node that we want to remove
            if(first.number==val)
            {
                node victim = first;
                first = victim.next;
                num_of_elements--;
                return victim.number;
            }
            //else
            node current_node = first;
            while(current_node.next!=null)
            {
                if(current_node.next.number==val)
                {
                    node victim = current_node.next;
                    current_node.next = victim.next;
                    num_of_elements--;
                    return current_node.number;
                }
                current_node = current_node.next;
            }
        }
        //if the while loop is done but we do not end up in a return, we throw an exception
        throw new Exception("Integer not find");
    }

    //insert a number with value val at the position pos, note that the position begins at 1
    //Note that we do not make the insertion overwriting the former element, if any
    //throw an exception when the index is invalid
    public void insert(int pos, int val) throws Exception
    {
        if(pos>num_of_elements+1 || pos <=0)
        {
            throw new Exception("The index is invalid");
        }
        if(pos==1)
        {
            node np = new node(val);
            np.next = first;
            first = np;
            num_of_elements++;
            return;
        }
        node current_node = first;
        while(pos-2!=0)
        {
            current_node=current_node.next;
            pos--;
        }
        node np = new node(val);
        np.next = current_node.next;
        current_node.next=np;
        num_of_elements++;
    }

    //return the index of the node which contains the value
    // throw an exception if the number is not find
    public int find_by_value(int val) throws Exception
    {
        //Note that the index for the first point is one
        int index=1;
        node current_node = first;
        while(current_node!=null)
        {
            if(current_node.number==val)
            {
                return index;
            }
            index++;
            current_node=current_node.next;
        }
        throw new Exception("The number is not found");
    }

    //Return the index of a certain value
    //throw an exception if the index is not valid, note that the index begins at 1
    public int find_by_index(int index) throws Exception
    {
        if(index<=0 || index>num_of_elements)
        {
            throw new Exception("The index is not valid");
        }
        node current_node = first;
        while(index!=1)
        {
            current_node = current_node.next;
            index--;
        }
        return current_node.number;
    }

    //print the whole list one by one, separated by a space
    public void print()
    {
        node current_node = first;
        while(current_node!=null)
        {
            System.out.print(current_node.number);
            System.out.print(" ");
            current_node=current_node.next;
        }
    }

    //default constructor
    public single_ended_singlely_linked_list()
    {
        first=null;
        num_of_elements=0;
    }

    //construct the linked list with single node
    //not that this is not a deep copy
    public single_ended_singlely_linked_list(node n)
    {
         first=n;
         num_of_elements=1;
    }

    //The copy constructor
    public single_ended_singlely_linked_list(single_ended_singlely_linked_list list) throws Exception
    {
        //firstly, we copy the number of elements
        num_of_elements= list.num_of_elements;
        //Then we copy the elements one by one
        node current_node = list.first;
        //The int pos gives the current position of the target, should increment while inserting
        int pos=1;
        while(current_node!=null)
        {
            try
            {
                insert(pos,current_node.number);
                pos++;
            }
            catch(Exception e)
            {
                System.out.println("The index is invalid, please input a right index");
            }
            current_node=current_node.next;
        }
    }
}
